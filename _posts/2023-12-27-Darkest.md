---
layout: post
title: "Dark Launching and Shadow Testing"
description: "'[Dark Launching](https://martinfowler.com/bliki/DarkLaunching.html)' refers to feature enablement in production behind the scenes, like 'Shadow Testing', which is the testing process of new application features in the background without making them generally available."
date: 2023-12-27 08:41:50
author: Erhan Bagdemir
comments: true
keywords: "Testing, Dark Launching, Shadow Testing, Release"
category: Testing
image:  '/images/21.jpg'
tags:
- Testing
- Dark Launching
- Shadow Testing
---

'[Dark Launching](https://martinfowler.com/bliki/DarkLaunching.html)' refers to feature enablement in production behind the scenes, like '[Shadow Testing](https://microsoft.github.io/code-with-engineering-playbook/automated-testing/shadow-testing/)', which is the testing process of new application features in the background without making them generally available. It aims to activate new software features before the GA without interrupting the operations and being transparent to customers. During the testing phase, you are to monitor, for example, whether the new integration works seamlessly with existing components under realistic data and load. '[Dark Launching](https://martinfowler.com/bliki/DarkLaunching.html)' and '[Shadow Testing](https://microsoft.github.io/code-with-engineering-playbook/automated-testing/shadow-testing/)' are indeed very similar in practice and differ only in their intended purpose — and occasionally, they are used interchangeably. 

The main goal in '[Dark Launching](https://martinfowler.com/bliki/DarkLaunching.html)' is to observe the behavior of the new application features under the realistic workload in the production environment. Clients are mostly unaware of the test running in the background. '[Shadow Testing](https://microsoft.github.io/code-with-engineering-playbook/automated-testing/shadow-testing/)', very like '[Dark Launching](https://martinfowler.com/bliki/DarkLaunching.html)', is usually run on production systems against real customer requests. Customer requests are processed by the existing software components during [Shadow Testing](https://microsoft.github.io/code-with-engineering-playbook/automated-testing/shadow-testing/), while triggering the new components at the same time. The response from the new component is often not returned to the customer, and it is to simulate the integration of the new feature with the rest of the application. In case of an error, the output is logged out in a way that the engineering team can investigate, and the response from the existing integration is returned to the customer.

'[Shadow Testing](https://microsoft.github.io/code-with-engineering-playbook/automated-testing/shadow-testing/)' can be considered an integration test with real data without the customer noticing. You might wonder why integration tests alone aren't sufficient for testing the new software components. Integration tests are conducted with test users and synthetic data, attempting to mimic production data. However, synthetic data may not provide the same complexity as data generated by customers in production systems. This inevitably leads to gaps in test coverage. Therefore, integration tests may not catch all errors that could occur in production operations; hence, '[Shadow Testing](https://microsoft.github.io/code-with-engineering-playbook/automated-testing/shadow-testing/)' becomes a valid option before enabling the new integration. In the next section, we will explore a new library I am currently working on, which facilitates the rollout of complicated releases without putting you on a tightrope.

## The “Darkest” comes to help

[Darkest](https://github.com/reevik/darkest) is a [Shadow Testing](https://microsoft.github.io/code-with-engineering-playbook/automated-testing/shadow-testing/) and [Dark Launching](https://martinfowler.com/bliki/DarkLaunching.html) library developed for Java web services. As new service integrations always come and go, [Shadow Testing](https://microsoft.github.io/code-with-engineering-playbook/automated-testing/shadow-testing/) enables development teams to carry out endpoint switches of service dependencies in a graceful way by calling both endpoints, say, A and B, and comparing their API responses. You can simply add the following maven dependency to your project to get started: 

```xml
    <dependency>
      <groupId>net.reevik</groupId>
      <artifactId>darkest</artifactId>
      <version>0.1.0</version>
    </dependency>
```

### Usage

You can consider the following code snippet how the routing configuration and router instance are created: 

```java
    RoutingConfiguration<String> routingConfiguration=Builder.<String>create()
    .withSideA(()-> serviceOld.call())
    .withSideB(()-> serviceNew.call())
    .withResultValidator(mustEqual())
    .withRoutingCriterion(new CountingCondition(nthRequest))
    .withRoutingMode(RoutingMode.SHADOW_MODE_ACTIVE)
    .build();
    
    EndpointRouter<String> router = new EndpointRouter<>(routingConfiguration);
    String result=router.route();
```

The **RoutingConfiguration** takes two commands which implement the integration logic with the A and B endpoints. The **RoutingConfiguration** instance requires a validator which is used to compare the response objects from A and B endpoints, whereas a routing criterion to decide when the B side needs to 
be called. The **Routing Mode** defines the operating mode of the EndpointRouter. A_SIDE is used to route all requests to the A endpoint (the existing integration) and B_SIDE works like A_SIDE, but this time all requests will be routed to the B endpoint (the new integration). **SHADOW_MODE_PASSIVE** results in calling both endpoints simultaneously. If the A-B validation succeeds, in other words A and B endpoint's results are compatible, the **EndpointRouter** returns the result object from the A side, **SHADOW_MODE_ACTIVE**, in case the A-B validation succeeds, it returns the result object from the B side.

The modes which require both sides to get activates, like SHADOW_MODE_PASSIVE, leverage Java's virtual threads. So, it is important to note that using synchronized blocks within the command implementation may end up with pinned platform threads. Therefore, I encourage you to use, ReentrantLocks instead.

### Validators

Result validation is used to evaluate the result objects from both integration so that the framework can take action if two results are compatible or incompatible. Depending on the routing mode selected, if both results are equal, the routed may return the result object from the new integration. It means, the [Darkest](https://github.com/reevik/darkest) can roll out the new feature by activating the new integration if the validation passes. 

[Darkest](https://github.com/reevik/darkest) brings a few simple validators, which you can use out-of-the-box. Let's take two of them, which, I presume, will be used mostly:

* [mustEqual](https://reevik.github.io/darkest/net/reevik/darkest/validators/ValidatorFactory.html#mustEqual())
* [mustPerformSimilar](https://reevik.github.io/darkest/net/reevik/darkest/validators/ValidatorFactory.html#mustPerformSimilar(java.time.Duration))

Anyway, the validators are not limited to those above. You can write your own validators depending on your needs by extending the framework. 

### Routing Criterion

Routing criteria are preconditions for the router to determine when to enable the new integration. For example, the CountingCondition implements the logic which allows every n'th request to be routed to the new integration. Like validators, the framework brings a few criteria implementation out-of-the-box.

## Wrap-up

[Darkest](https://github.com/reevik/darkest) is a simple framework to validate two execution paths, they are implemented as commands. It will route the incoming requests depending on the routing criterion and assess the outcome from the execution of both command. You can enhance the library by implementing new Monitorables, e.g., whenever the new endpoint gets called or the endpoint responses diverge, you can register new metrics at your monitoring endpoint and make the roll-out visible. If you have new ideas, feel free to join the project: 
[https://github.com/reevik/darkest](https://github.com/reevik/darkest)